## История CSS-препроцессоров в БЭМ

Тема CSS-препроцессоров не нова, но все еще очень актуальна для фронтенд-разработчиков. В то время, когда весь мир фронтенд-разработки решил изменить свое отношение к организации стилей и перестать писать чистый CSS, БЭМ не остался в стороне.

В этой небольшой статье мы расскажем вам, чем руководствовались, на чем обожглись и как выбирали тот или иной CSS-препроцессор для БЭМ-методолгии.

Но сначала немного лирики...

## Почему возникла необходимость выбора препроцессора

За время своего существования БЭМ-методология обросла большим количеством внутренних и внешних библиотек, которые насчитывают множество различных блоков, реализованных в разных темах. Развитие и поддержка разных вариаций оформления блоков и элементов требовало привлечения дополнительных инструментов для облегчения жизни разработчиков. Вопрос о выборе CSS-препроцессора становился все более актуальным.

Использование препроцессора позволяло уйти от написания длинных названий классов в селекторах, упрощало синтаксис и делало код более чистым и логичным. Возможность использования специализированных под CSS функций и создания вложенных селекторов, добавление переменных и повторное использование свойств CSS делало код модульным и масштабируемым.

Было принято решение начать использовать CSS-препроцессор в БЭМ-методологии.

Так как препроцессор необходимо было внедрять в уже существующие библиотеки, которые использовались в запущенных проектах, сформировались определенные требования, которым препроцессор должен был соответствовать:

* поддержка существующего CSS-кода без дополнительных изменений;
* препроцессор должен быть написан на JavaScript;
* достаточно гибкая и легко масштабируемая архитектура;
* простой и понятный синтаксис.

## Выбор препроцессора: плюсы и минусы

В выборе участвовало несколько кандидатов:

* [Sass](http://sass-lang.com/)
* [LESS](http://lesscss.org/)
* [Stylus](http://learnboost.github.io/stylus/)
* [Roole](http://roole.org/)

Все перечисленные препроцессоры предоставляют примерно одинаковую функциональность. Все они поддерживают:

* переменные (variables);
* миксины (mixings);
* вложенность (nesting);
* циклы и условия (loops and conditions);
* выделение цветом (colour transformation);
* импорт (importing).

Но реализация этих функций и наличие дополнительных «плюшек» играют главную роль при выборе препроцессора.

Начнем обзор с **Sass**, самого развитого и известного CSS-препроцессора. Он поддерживает обширную функциональность, достаточно быстрый и имеет большое и активно развивающееся сообщество. Sass написан на Ruby и это одна из основных причин, почему он не подходит для БЭМ-методолгии. Вторая причина заключается в особенности использования некоторых функций, например, `parent reference` (знака `&` для отсылки к родительскому селектору), что затрудняет применение БЭМ-селекторов.

**Less** использует очень простой синтаксис, основанный на CSS. Это достаточно быстрый процессор, написанный на JavaScript-е. С него легко начинать знакомство с препроцессорами, но его функциональность слишком ограничена. Как только появляется более или менее сложная проблема, Less-а становится недостаточно.

**Stylus** – препроцессор по функциональности близкий к Sass, и в отличие от него написан на JavaScript. Stylus считался одним из основных претендентов, подходящих БЭМ, так как имел ряд плюсов:

* Очень гибкий синтаксис. Точнее поддержка двух видов синтаксиса, один из которых позволяет писать код, практически как обычный CSS, другой – предоставляет сокращенный синтаксис, основанный на отступах и с минимумом лишних символов.
* Поддержка  прозрачных миксинов, благодаря которым любое свойство в CSS можно переопределить на вызов функции.
* Разработка препроцессора в Яндексе и опыт использования его сервисах – Почте и Картах.

Однако Stylus к тому времени был все еще далек от идеала – он имел несколько существенных недостатков, «несовместимых с жизнью» в БЭМ-методологии. Основной проблемой, как бы странно это не звучало, было одно из его основных достоинств – гибкий синтаксис. Поддержка двух видов синтаксиса усложняла архитектуру парсера и накладывала свои ограничения: сокращенный синтаксис был реализован в полной мере и мог применяться для написания нового CSS-кода. Тогда как основанный на CSS синтаксис не имел полной обратной совместимости с чистым CSS: не было гарантии, что все варианты написания CSS заработают в Stylus.
Еще одним весомым аргументом против было то, что Stylus развивался слишком медленно.

Таким образом было принято решение отказаться и от Stylus в пользу молодого и мало кому известного препроцессора Roole.

**Roole** был самым новым и стремительно развивающимся препроцессором на тот момент. Хотя он практически не имел своего сообщества и поддерживался одним разработчиком, в его активах уже имелось большинство необходимых БЭМ-у [функций](http://roole.org/documentation/). Roole был написан на JavaScript, а его синтаксис практически совпадал с Sass и Stylus. Также Roole умел обращаться с длинными [названиями классов в слекторах](http://noteskeeper.ru/1139/), которые так свойственны БЭМ. Главным плюсом, как мы тогда считали, был генерируемый парсер [PEG.js](https://github.com/dmajda/pegjs) с гибкой, легко расширяемой модульной архитектурой.

Благодаря тому, что создатель Roole имел возможность учиться на ошибках, с которыми столкнулись более ранние препроцессоры, вся функциональность была хорошо продумана и доработана. Одним из решающих факторов в пользу Roole была поддержка чистого CSS-кода, что давало возможность без дополнительных усилий начать применять его в уже существующих библиотеках и проектах.

Таким образом БЭМ-методология пополнилась еще одним инструментом, а в составе каждого блока наряду с `.css`-файлом появился файл `.roo`.

Использование препроцессора не стало жестким требованием БЭМ-методолгии. На случай, если сервис использовал какой-либо несовместимый препроцессор или принципиально не хотел использовать Roole, был предусмотрен вариант поставки библиотеки с предкомпилированным CSS.

## Пришла беда, откуда не ждали

После года использования Roole мы неожиданно столкнулись с серьезной проблемой. То, что раньше считалось основным плюсом препроцессора, оказалось его основной проблемой: парсер PEG.js показал очень плохие результаты по времени компеляции.

Таблица показывает разницу во времени компиляции для всех четырех препроцессоров:

<table>
    <tr>
        <td rowspan="2"> Количество итераций </td>
        <td colspan="4"> Время компиляции, мс </td>
    </tr>
    <tr>
        <td> Roole </td>
        <td> Stylus </td>
        <td> LESS </td>
        <td> Sass </td>
    </tr>
    <tr>
        <td> 1 </td>
        <td> 23 </td>
        <td> 10 </td>
        <td> 6 </td>
        <td> 180 </td>
    </tr>
    <tr>
        <td> 10 </td>
        <td> 100 </td>
        <td> 28 </td>
        <td> 11 </td>
        <td> 206 </td>
    </tr>
    <tr>
        <td> 100 </td>
        <td> 3318 </td>
        <td> 118 </td>
        <td> 37 </td>
        <td> 545 </td>
    </tr>
    <tr>
        <td> 1000 </td>
        <td> бесконечность </td>
        <td> 930 </td>
        <td> 207 </td>
        <td> 4000 </td>
    </tr>
</table>

Тесты проводились на основе [bench](https://gist.github.com/Panya/5337f4709264477a2358#file-bench)-файла.

Такое поведение препроцессора стало совершенно неприемлимым для использования в методологии. Дополнительным фактором отказа от Roole стало также и то, что его автор перестал отвечать на запросы и вообще прекратил поддержку и разработку своего проекта.

## Новый виток в выборе препроцессора

Выбор нового препроцессора на этот раз оказался не таким мучительным. За этот недолгий период разработчики Stylus (Роман Комаров и Михаил Корепанов) хорошо продвинули препроцессор вперед и решили многие его проблемы.

Таким образом Stylus, поддержкой и разработкой которого занимаются в Яндексе, стал новым CSS-препроцессором в БЭМ.

Миграция с одного препроцессора на другой – не сложный процесс: синтаксис и функциональность Roole и Stylus не слишком разнятся, а основная масса кода, написанного с использованием какого-либо препроцессора, достаточно просто автоматически преобразуется в другой синтаксис.

Переход на Stylus решает большинство текущих проблем, но это не гарантирует того, что мы не столкнемся с новыми в будущем. Так что, вполне вероятно, что Stylus – это тоже не финальная точка в истории препроцессоров в БЭМ.

Выбор того или иного препроцессора полностью зависит от потребностей проекта. С развитием БЭМ, возможно, мы столкнемся с необходимостью поиска новых возможностей за пределами Stylus.
