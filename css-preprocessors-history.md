## История CSS-препроцессоров в bem-components

Тема CSS-препроцессоров не нова, но все еще очень актуальна для фронтенд-разработчиков. В то время, когда весь мир фронтенд-разработки решил изменить свое отношение к организации стилей и перестать писать чистый CSS, мы не остались в стороне.

В этой небольшой статье мы расскажем вам, чем руководствовались, на чем обожглись и как выбирали CSS-препроцессор для библиотеки [bem-components](https://github.com/bem/bem-components).

Но сначала немного лирики...

## Почему возникла необходимость выбора препроцессора

Использование препроцессора позволяло уйти от написания длинных названий классов в селекторах, упрощало синтаксис и делало код более чистым и логичным. Возможность использования специализированных под CSS функций и создания вложенных селекторов, добавление переменных и повторное использование свойств CSS делало код модульным и масштабируемым.

Было принято решение начать использовать CSS-препроцессор в bem-components.

Так как препроцессор необходимо было внедрять в уже существующие библиотеки, которые использовались в запущенных проектах, сформировались определенные требования, которым препроцессор должен был соответствовать:

* поддержка существующего CSS-кода без дополнительных изменений;
* выразительность и функциональность;
* препроцессор должен быть написан на JavaScript.

## Выбор препроцессора: плюсы и минусы

В выборе участвовало несколько кандидатов:

* [Sass](http://sass-lang.com/)
* [Less](http://lesscss.org/)
* [Stylus](http://learnboost.github.io/stylus/)
* [Roole](http://roole.org/)

Все перечисленные препроцессоры предоставляют примерно одинаковую функциональность. Все они поддерживают:

* переменные (variables);
* миксины (mixings);
* вложенность (nesting);
* циклы и условия (loops and conditions);
* выделение цветом (colour transformation);
* импорт (importing).

Но реализация этих функций и наличие дополнительных «плюшек» играют главную роль при выборе препроцессора.

Начнем обзор с **Sass**, самого развитого и известного CSS-препроцессора. Он поддерживает обширную функциональность, достаточно быстрый и имеет большое и активно развивающееся сообщество. Однако в Sass есть свое видение поддержки некоторых функций, например, `parent reference` (знака `&` для отсылки к родительскому селектору), что затрудняет применение БЭМ-селекторов. И это одна из основных причин, почему использование этого препрцессора не очень удобно в библиотеке bem-components.

Sass написан на Ruby, что также не облегчает его интеграцию в наши библиотеки, так как все используемые инструменты сборки написаны на JavaScript. Один язык разработки для всех инструментов требует указания меньшего числа зависимостей, а также понижает порог входа в использование библиотеки для фронтенд-разработчиков.

**Less** использует очень простой синтаксис, основанный на CSS. Это достаточно быстрый процессор, написанный на JavaScript. С него легко начинать знакомство с препроцессорами, но его функциональность слишком ограничена. Как только появляется более или менее сложная проблема, Less становится недостаточно. Например, ограниченные возможности работы с циклами и массивами не могут решить всех требований наших библиотек.

```
for rule in ((bottom (left center right)) (top (left center right)) (right (top center bottom)) (left (top center bottom))) {
    for secondary in rule[1] {
        {ctx}.popup_direction_{rule[0]}-{secondary} {
            animation-name: popup_theme_normal_ + rule[0];
        }
    }
    for secondary in rule[1] {
        {ctx}.popup_direction_{rule[0]}-{secondary}.popup_visible {
            animation-name: popup_theme_normal_ + rule[0] + _visible;
        }
    }
}
```

**Stylus** – препроцессор по функциональности близкий к Sass, и в отличие от него написан на JavaScript. Stylus считался одним из основных претендентов, подходящих bem-components, так как имел ряд плюсов:

* Очень гибкий синтаксис. Точнее поддержка двух видов синтаксиса, один из которых позволяет писать код, практически как обычный CSS, другой – предоставляет сокращенный синтаксис, основанный на отступах и с минимумом лишних символов.
* Поддержка прозрачных миксинов, благодаря которым любое свойство в CSS можно переопределить на вызов функции.
* Разработка препроцессора в Яндексе и опыт использования его сервисах – Почте и Картах.

R тому времени Stylus был все еще далек от идеала – он имел несколько существенных недостатков, «несовместимых с жизнью» в bem-components. Основной проблемой, как бы странно это не звучало, было одно из его основных достоинств – гибкий синтаксис. Поддержка двух видов синтаксиса усложняла архитектуру парсера и накладывала свои ограничения: сокращенный синтаксис был реализован в полной мере и мог применяться для написания нового CSS-кода. Тогда как основанный на CSS синтаксис не имел полной обратной совместимости с чистым CSS: не было гарантии, что все варианты написания CSS заработают в Stylus.
Еще одним весомым аргументом «против» было то, что Stylus развивался слишком медленно.

Таким образом в конце марта 2013 года было принято решение отказаться и от Stylus 4.0 в пользу молодого и мало кому известного препроцессора Roole.

**Roole** был самым новым и стремительно развивающимся препроцессором на тот момент. Хотя он практически не имел своего сообщества и поддерживался одним разработчиком, в его активах уже имелось большинство необходимых bem-components [функций](http://roole.org/documentation/). Roole был написан на JavaScript, а его синтаксис практически совпадал с Sass и Stylus. Также Roole умел обращаться с длинными [названиями классов в слекторах](http://noteskeeper.ru/1139/), которые так свойственны БЭМ. Главным плюсом, как мы тогда считали, был генерируемый парсер [PEG.js](https://github.com/dmajda/pegjs) с гибкой, легко расширяемой модульной архитектурой. Такой парсер делал Roole очень устойчивым к различным стилям кодирования и не вынуждал разработчика писать код каким-то строго определенным образом.

Благодаря тому, что создатель Roole имел возможность учиться на ошибках, с которыми столкнулись более ранние препроцессоры, вся функциональность была хорошо продумана и доработана. Одним из решающих факторов в пользу Roole была поддержка чистого CSS-кода, что давало возможность без дополнительных усилий начать применять его в уже существующих библиотеках и проектах.

Таким образом БЭМ-методология пополнилась еще одним инструментом, а в составе каждого блока наряду с `.css`-файлом появился файл `.roo`.

Использование препроцессора не стало жестким требованием библиотеки. На случай, если сервис использовал какой-либо несовместимый препроцессор или принципиально не хотел использовать Roole, предполагался вариант поставки библиотеки с предкомпилированным CSS.

## Возникшие проблемы

После нескольких месяцев использования Roole мы неожиданно столкнулись с серьезной проблемой. То, что раньше считалось основным плюсом препроцессора, оказалось его основной проблемой: парсер PEG.js показал очень плохие результаты по времени парсинга.

Таблица показывает разницу во времени компиляции для всех четырех препроцессоров:

<table>
    <tr>
        <th rowspan="2"> Количество итераций </th>
        <th colspan="4"> Время компиляции, мс </th>
    </tr>
    <tr>
        <th> Roole </th>
        <th> Stylus </th>
        <th> Less </th>
        <th> Sass </th>
    </tr>
    <tr>
        <td> 1 </td>
        <td> 23 </td>
        <td> 10 </td>
        <td> 6 </td>
        <td> 180 </td>
    </tr>
    <tr>
        <td> 10 </td>
        <td> 100 </td>
        <td> 28 </td>
        <td> 11 </td>
        <td> 206 </td>
    </tr>
    <tr>
        <td> 100 </td>
        <td> 3318 </td>
        <td> 118 </td>
        <td> 37 </td>
        <td> 545 </td>
    </tr>
    <tr>
        <td> 1000 </td>
        <td> 5000+ </td>
        <td> 930 </td>
        <td> 207 </td>
        <td> 4000 </td>
    </tr>
</table>

Тесты проводились на основе универсального файла ([bench](https://gist.github.com/Panya/5337f4709264477a2358#file-bench)), компилируемого всеми препроцессорами.

Такая скорость работы парсера стала совершенно неприемлемой для использования в реальных «живых» проектах. Дополнительным фактором отказа от Roole стало также и то, что его автор перестал отвечать на запросы и вообще прекратил поддержку и разработку своего проекта.

## Новый виток в выборе препроцессора

Выбор нового препроцессора на этот раз оказался не таким мучительным. За этот недолгий период разработчики Stylus (Роман Комаров и Михаил Корепанов) хорошо продвинули препроцессор вперед и решили многие его проблемы.

Таким образом Stylus, поддержкой и разработкой которого занимаются в Яндексе, стал новым CSS-препроцессором в bem-components.

Миграция с одного препроцессора на другой – относительно несложный процесс: синтаксис и функциональность Roole и Stylus не слишком разнятся, а основная масса кода, написанного с использованием какого-либо препроцессора, достаточно просто без изменений преобразуется в другой синтаксис. Однако несовместимые конструкции пришлось переписать руками.

Переход на Stylus решает большинство текущих проблем, но это не гарантирует того, что мы не столкнемся с новыми в будущем.

Выбор того или иного препроцессора полностью зависит от потребностей проекта. С развитием библиотеки, возможно, мы столкнемся с необходимостью поиска новых возможностей за пределами Stylus.
